<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>    How to Make Computers Stop Being Racist
</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width">
            <link rel="stylesheet" href="./theme/css/normalize.css">
        <link href='//fonts.googleapis.com/css?family=Lato' rel='stylesheet' type='text/css'>
        <link href='//fonts.googleapis.com/css?family=Oswald' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="./theme/css/font-awesome.min.css">
        <link rel="stylesheet" href="./theme/css/main.css">

    <link rel="stylesheet" href="./theme/css/blog.css">
    <link rel="stylesheet" href="./theme/css/github.css">
        <script src="./theme/js/vendor/modernizr-2.6.2.min.js"></script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
        <![endif]-->

        <div id="wrapper">
<header id="sidebar" class="side-shadow">
    <hgroup id="site-header">
        <a id="site-title" href="."><h1><i class="icon-bar-chart"></i> Aleks</h1></a>
        <p id="site-desc"></p>
    </hgroup>
    <nav>
        <ul id="nav-links">
                <li><a href="./tag/blog.html">Blog</a></li>
                <li><a href="./pages/contact">Contact</a></li>
                <li><a href="./pages/bio">Bio</a></li>
                <li><a href="./pdfs/resume.pdf">Resume</a></li>
        </ul>
    </nav>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="1348.17">
  <style type="text/css">
  </style>
</head>
<body>
</body>
</html></header>
    <div id="post-container">
        <ol id="post-list">
            <li>
                <article class="post-entry">
                    <header class="entry-header">
                        <time class="post-time" datetime="2016-04-10T16:27:00-05:00" pubdate>
                            Sun 10 April 2016
                        </time>
                        <a href="./how-to-make-computers-stop-being-racist.html" rel="bookmark"><h1>How to Make Computers Stop Being Racist</h1></a>
                    </header>

                    <section class="post-content">
                        <p>Can statistical models discriminate against a group of people without the intent 
of the creator? Microsoft's recent experiment with the Twitter artificial intelligence 
bot Tay suggests the answer is a firm yes. The bot was programmed to resemble an 
impulsive teenager, but ended up denying the holocaust ever happened, while simultaneously 
advocating a genocide of Mexicans. In an 
<a href="http://www.fordfoundation.org/ideas/equals-change-blog/posts/can-computers-be-racist-big-data-inequality-and-discrimination/">article</a> 
entitled "Can Computers Be Racist," Michael Brennan discussed how algorithms can 
and do display preferences for certain groups in some depth and I will not go 
farther into it.</p>
<p>Instead, I am going to follow up and propose a possible solution. In short, I am 
going to outline three possible ways statistical models can treat differences 
between groups. The first is by explicitly taking advantage of them in order to 
improve prediction. The second is by ignoring differences, but still giving 
preferential results to certain groups. The third is by accounting for group 
differences and giving the same results to people regardless of the group they 
belong to.</p>
<h1>The Example</h1>
<p>Imagine we are trying to design a tool to help police officers identify criminal suspects more effectively, thereby reducing the need to stop innocent people. The goal would be to have the police officer enter some information about the suspect and the situation and have the algorithm provide the officer a decision: confront the person or not. In the best case scenario, if such a tool were highly accurate and neutral with respect to racial group, it could reduce the amount of needless stops and reduce frictions between police officers and the communities they serve. In the worst case scenario, if the tool takes advantage of the fact that there are higher rates of criminal incidence among racial minorities, it would result in more stops of people who belong to those racial minorities and increase tensions between police and the communities they serve.</p>
<p>Fortunately, the New York Police Department releases troves of data about its stop and frisk campaign (cudos). Using these data, we can predict the likelihood for some person who is suspected of a crime to be arrested based on background characteristics, the officer's suspicions, the time and location of the confrontation etc..</p>
<p>Note that what I am advocating here is a technique and not necesserily its use in this context. The specific tool that I am proposing could be easily gamed and what I am trying to predict here (whether a person is arrested) does not actually indicate guilt.</p>
<h1>A First Approach</h1>
<p>The first thing we could try is to make a model that includes a whole lot of variables (including demographics) and then make predictions using all these variables. Although it seems outrageous to use statistical models that explicitly include demographic characteristics to make impactful decisions, it is actually a common practice (thankfully not as frequently for historically disadvantaged groups). For example, insurance companies include gender, age, and marital status in assessing risk and therefore insurance payments.</p>
<p>Specifically, I used the NYPD's data about stop and frisk to predict which confrontations resulted in arrests. As predictors, I used features of the confrontation (e.g., the time and place), features of the suspect (e.g., gender, race, age, height, weight, haircolor, build), the officer's reasons for confronting the suspect (e.g., suspicious bulge), whether the officer was in uniform and other circumstances (e.g.,   proximity to scene of a crime).</p>
<p>Because there were so many variables, I used regularization to select the ones that were actually useful and because regularization introduces a hyper-parameter, I used cross-validation to select the best hyper-parameter.</p>
<p>To validate the model, I left 1000 people suspected of a crime out for final evaluation. Of these 1000, 156 were arrested when confronted. Because no model can be perfect, some of these people who should be arrested will be missed. I set this percentage to 5%, meaning 8 people who would have been arrested would walk free. Using this criterion allowed 30.5% of people not to be stopped at all. The problem with this model was that </p>
<h1>A Proposed Solution</h1>
<p>The approach I discuss here is to use a machine learning algorithm to learn what characteristics of the labeled questions give them the topics that they have and extrapolate that to the unlableled questions. I will do this in <code>R</code> using the <code>tm</code> and <code>randomForest</code> packages. There will be a separate model for each label.</p>
<div class="highlight"><pre>&gt; require(plyr)
&gt; require(tm)
</pre></div>


<p>The first thing to do is to read in the file to see what we're dealing with. This file is made publically available by the Good Judgment Project.</p>
<div class="highlight"><pre><span class="x">&gt; ifps = read.csv(&#39;ifps.csv&#39;, header=T, stringsAsFactors = F)</span>
<span class="x">&gt; head(ifps</span><span class="p">$</span><span class="nv">q_text</span><span class="x">)</span>
<span class="x">[1] &quot;Will the Six-Party talks (among the US, North Korea, South Korea, Russia, China, and Japan) formally resume in 2011?&quot;</span>
<span class="x">[2] &quot;Who will be inaugurated as President of Russia in 2012?&quot;</span>
<span class="x">[3] &quot;Will Serbia be officially granted EU candidacy by 31 December 2011?&quot;</span>
<span class="x">[4] &quot;Will the United Nations General Assembly recognize a Palestinian state by 30 September 2011?&quot;</span>
<span class="x">[5] &quot;Will Daniel Ortega win another term as President of Nicaragua during the late 2011 elections?&quot;</span>
<span class="x">[6] &quot;Will Italy restructure or default on its debt by 31 December 2011?&quot;</span>
<span class="x">&gt; head(ifps</span><span class="p">$</span><span class="nv">tags</span><span class="x">[ifps</span><span class="p">$</span><span class="nv">tags</span><span class="x">!=&#39;&#39;]) </span><span class="cp">#</span><span class="nf">view</span><span class="x"> the first six tags</span>
<span class="x">[1] &quot;|Middle-East|Law|&quot;</span>
<span class="x">[2] &quot;|Middle-East|Conflict-Interstate|Diplomacy|Iran|&quot;</span>
<span class="x">[3] &quot;|Asia-East|Pacific_Rim|Korea|Diplomacy|Military|&quot;</span>
<span class="x">[4] &quot;|Asia-East|Europe|China|Economics|Law|&quot;</span>
<span class="x">[5] &quot;|Asia-East|Pacific_Rim|Japan|Elections|&quot;</span>
<span class="x">[6] &quot;|Middle-East|&quot;</span>
</pre></div>


<p>It seems that a question can be given more than one topic (or tag) and the tags are separated by the <code>|</code> character in the tags. </p>
<p>We would like to be able to predict which topic(s) in <code>ifps$tags</code> are appropriate to a question based on the text in <code>ifps$q_text</code>. For that, we need one matrix that tells us which articles have which topics (that's what we want to predict) and a second matrix that tells us which words are in which article.</p>
<p>To get there, let's get a list of all the possible topics. These will be the names of the columns of the first matrix. First, we split them by the <code>|</code>character, and collect the output in one list and store the distinct elements of this list under topics.</p>
<div class="highlight"><pre><span class="x">&gt; topics = unique(unlist(strsplit(ifps</span><span class="p">$</span><span class="nv">tags</span><span class="x">, split=&#39;\\|&#39;)))</span>
<span class="x">&gt; topics = topics[c(-1,-length(topics))] </span><span class="cp">#</span><span class="nf">the</span><span class="x"> first and last topics were &quot;&quot; and &quot;0&quot;</span>
<span class="x">&gt; length(topics) </span><span class="cp">#</span><span class="nf">how</span><span class="x"> many topics are there?</span>
<span class="x">[1] 59</span>
</pre></div>


<p>We want a matrix with one row for each question and one column for each of the distinct topics, and for the entries, we want an indicator letting us know whether that question was labeled with that topic. The <code>ldply</code> function from the <code>plyr</code> package does just that. It applies a function to a list (in our case the list of topic vectors).</p>
<div class="highlight"><pre><span class="o">&gt;</span> <span class="nx">require</span><span class="p">(</span><span class="nx">plyr</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="nx">topicMat</span> <span class="o">=</span> <span class="nx">ldply</span><span class="p">(</span> <span class="nx">strsplit</span><span class="p">(</span><span class="nx">ifps$tags</span><span class="p">,</span> <span class="nx">split</span><span class="o">=</span><span class="s1">&#39;\\|&#39;</span><span class="p">),</span> 
<span class="o">+</span>                   <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="nx">topics</span> <span class="o">%</span><span class="k">in</span><span class="o">%</span> <span class="nx">x</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="nx">names</span><span class="p">(</span><span class="nx">topicMat</span><span class="p">)</span> <span class="o">=</span> <span class="nx">topics</span> <span class="err">#</span><span class="nx">Give</span> <span class="nx">the</span> <span class="nx">columns</span> <span class="nx">the</span> <span class="nx">appropriate</span> <span class="nx">names</span>
<span class="o">&gt;</span> <span class="nx">topicMat</span> <span class="o">=</span> <span class="nx">topicMat</span><span class="cp">[</span><span class="nx">colSums</span><span class="p">(</span><span class="nx">topicMat</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">10</span><span class="cp">]</span> <span class="err">#</span><span class="nx">Get</span> <span class="nx">rid</span> <span class="nx">of</span> <span class="nx">any</span> <span class="nx">topics</span> <span class="nx">used</span> <span class="nx">less</span> <span class="nx">than</span> <span class="mi">10</span> <span class="nx">times</span><span class="p">.</span>
</pre></div>


<p>Well, our topics are now in the right shape, but we still need a matrix with one row for each question and one column for each possible word, indicating whether that question has that word in it. <code>R</code>'s text mining package, <code>tm</code>, is perfect for this.</p>
<div class="highlight"><pre><span class="o">&gt;</span> <span class="nx">mycorp</span> <span class="o">=</span> <span class="nx">Corpus</span><span class="p">(</span><span class="nx">VectorSource</span><span class="p">(</span><span class="nx">q_text</span><span class="p">))</span> <span class="err">#</span><span class="nx">turn</span> <span class="nx">the</span> <span class="nx">questions</span> <span class="nx">into</span> <span class="nx">a</span> <span class="nx">corpus</span>
<span class="o">&gt;</span> <span class="nx">mycorp</span> <span class="o">=</span> <span class="nx">tm_map</span><span class="p">(</span><span class="nx">mycorp</span><span class="p">,</span> <span class="nx">PlainTextDocument</span><span class="p">)</span> <span class="err">#</span><span class="nx">convenience</span> <span class="kd">function</span>
<span class="o">&gt;</span> <span class="nx">mycorp</span> <span class="o">=</span> <span class="nx">tm_map</span><span class="p">(</span><span class="nx">mycorp</span><span class="p">,</span> <span class="nx">content_transformer</span><span class="p">(</span><span class="nx">tolower</span><span class="p">))</span> <span class="nx">change</span> <span class="nx">everything</span> <span class="nx">to</span> <span class="nx">lowercase</span>
<span class="o">&gt;</span> <span class="nx">mycorp</span> <span class="o">=</span> <span class="nx">tm_map</span><span class="p">(</span><span class="nx">mycorp</span><span class="p">,</span> <span class="nx">removePunctuation</span><span class="p">)</span> <span class="err">#</span><span class="nx">remove</span> <span class="nx">punctuation</span>
<span class="o">&gt;</span> <span class="nx">dtm</span> <span class="o">=</span> <span class="nx">DocumentTermMatrix</span><span class="p">(</span><span class="nx">mycorp</span><span class="p">)</span> <span class="err">#</span><span class="nx">make</span> <span class="nx">a</span> <span class="nb">document</span><span class="o">-</span><span class="nx">term</span> <span class="nx">matrix</span>
<span class="o">&gt;</span> <span class="nx">dtm</span> <span class="o">=</span> <span class="nx">removeSparseTerms</span><span class="p">(</span><span class="nx">dtm</span><span class="p">,</span> <span class="p">.</span><span class="mi">99</span><span class="p">)</span> <span class="err">#</span><span class="nx">remove</span> <span class="nx">terms</span> <span class="nx">that</span> <span class="nx">apeear</span> <span class="k">in</span> <span class="nx">fewer</span> <span class="nx">than</span> <span class="mi">1</span><span class="o">%</span> <span class="nx">of</span> <span class="nx">questions</span>
<span class="o">&gt;</span> <span class="nx">dtm2</span> <span class="o">=</span> <span class="nx">as</span><span class="p">.</span><span class="nx">matrix</span><span class="p">(</span><span class="nx">dtm</span><span class="p">)</span> <span class="err">#</span><span class="nx">change</span> <span class="k">this</span> <span class="nx">into</span> <span class="nx">a</span> <span class="nx">regular</span> <span class="nx">matrix</span>
<span class="o">&gt;</span> <span class="kr">class</span><span class="p">(</span><span class="nx">dtm2</span><span class="p">)</span> <span class="o">=</span> <span class="s2">&quot;numeric&quot;</span> <span class="err">#</span><span class="nx">change</span> <span class="nx">the</span> <span class="nx">values</span> <span class="nx">to</span> <span class="nx">numeric</span><span class="p">,</span> <span class="nx">as</span> <span class="nx">required</span> <span class="nx">by</span> <span class="nx">regression</span>
</pre></div>


<p>Now we're ready to train our algorithm. I find that random forests work really well for text data, so that is what I will use.</p>
<div class="highlight"><pre><span class="o">&gt;</span> <span class="nx">train</span> <span class="o">=</span> <span class="o">!</span><span class="nx">ifps$tags</span><span class="o">==</span><span class="s1">&#39;&#39;</span> <span class="err">#</span><span class="nx">train</span> <span class="nx">on</span> <span class="nx">the</span> <span class="nx">rows</span> <span class="nx">that</span> <span class="nx">are</span> <span class="nx">labeled</span>
<span class="o">&gt;</span> <span class="nx">rfs</span> <span class="o">=</span> <span class="nx">apply</span><span class="p">(</span> <span class="nx">topicMat</span><span class="cp">[</span><span class="nx">train</span><span class="p">,</span><span class="cp">]</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="err">#</span><span class="k">for</span> <span class="nx">each</span> <span class="nx">column</span> <span class="nx">of</span> <span class="nx">the</span> <span class="nx">topic</span> <span class="nx">matrix</span>
               <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="nx">randomForest</span><span class="p">(</span><span class="nx">dtm2</span><span class="cp">[</span><span class="nx">train</span><span class="p">,</span><span class="cp">]</span><span class="p">,</span> <span class="nx">factor</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nx">ntree</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
               <span class="err">#</span><span class="nx">train</span> <span class="nx">a</span> <span class="nx">random</span> <span class="nx">forest</span> <span class="kd">with</span> <span class="mi">200</span> <span class="nx">trees</span>
               <span class="p">)</span>
<span class="o">&gt;</span> <span class="nx">chosennames</span> <span class="o">=</span> <span class="nx">apply</span><span class="p">(</span> <span class="nx">dtm2</span><span class="cp">[</span><span class="o">!</span><span class="nx">train</span><span class="p">,</span><span class="cp">]</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">row</span><span class="p">)</span> <span class="p">{</span> <span class="err">#</span><span class="k">for</span> <span class="nx">each</span> <span class="nx">row</span> <span class="k">in</span> <span class="nx">the</span> <span class="nx">test</span> <span class="nx">set</span>
    <span class="nx">names</span><span class="p">(</span><span class="nx">topicMat</span><span class="p">)</span><span class="cp">[</span> <span class="vi">#choose</span> <span class="nx">the</span> <span class="nx">topic</span> <span class="nx">labels</span> <span class="nx">so</span> <span class="nx">that</span> 
        <span class="nx">unlist</span><span class="p">(</span><span class="nx">lapply</span><span class="p">(</span> <span class="nx">rfs</span><span class="p">,</span> <span class="nx">function</span><span class="p">(</span><span class="nx">rf</span><span class="p">)</span> <span class="nx">predict</span><span class="p">(</span><span class="nx">rf</span><span class="p">,</span> <span class="nx">row</span><span class="p">,</span> <span class="s1">&#39;prob&#39;</span><span class="p">)</span><span class="err">[</span><span class="mi">2</span><span class="cp">]</span><span class="o">&gt;</span><span class="p">.</span><span class="mi">4</span><span class="p">))</span> <span class="err">#</span><span class="nx">its</span> <span class="nx">probability</span> <span class="nx">according</span> <span class="nx">to</span> <span class="nx">our</span> <span class="nx">model</span> <span class="nx">is</span> <span class="nx">greater</span> <span class="nx">than</span> <span class="p">.</span><span class="mi">4</span>
        <span class="p">]</span> 
<span class="p">})</span>
</pre></div>


<h1>The Results</h1>
<p>The results are stored in the <code>chosennames</code> vector. For example, let's look at question 1:</p>
<div class="highlight"><pre><span class="x">&gt; ifps</span><span class="p">$</span><span class="nv">q_text</span><span class="x">[1]</span>
<span class="x">[1] &quot;Will the Six-Party talks (among the US, North Korea, South Korea, Russia, China, and Japan) formally resume in 2011?&quot;</span>
<span class="x">&gt; chosennames[1]</span>
<span class="p">$</span><span class="x">`1`</span>
<span class="x">[1] &quot;Diplomacy&quot;</span>
</pre></div>


<p>I think this is a good label, and in general, I found all the labels the algorithm assigned were appropriate, though even in the training set they did not always agree wiht the labels originally provided. However, problematically, the labels were only available for about a quarter of the test cases. </p>
<div class="highlight"><pre><span class="o">&gt;</span> <span class="nx">mean</span><span class="p">(</span><span class="nx">unlist</span><span class="p">(</span><span class="nx">lapply</span><span class="p">(</span><span class="nx">chosennames</span><span class="cp">[</span><span class="o">!</span><span class="nx">train</span><span class="cp">]</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span><span class="nx">length</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)))</span> <span class="err">#</span><span class="nx">proportion</span> <span class="nx">of</span> <span class="nx">test</span> <span class="nx">articles</span> <span class="nx">that</span> <span class="nx">weren</span><span class="err">&#39;</span><span class="nx">t</span> <span class="nx">labeled</span>
<span class="cp">[</span><span class="mi">1</span><span class="cp">]</span> <span class="mf">0.7282051</span>
<span class="o">&gt;</span> <span class="nx">ifps$q_text</span><span class="cp">[</span><span class="mi">4</span><span class="cp">]</span>
<span class="cp">[</span><span class="mi">1</span><span class="cp">]</span> <span class="s2">&quot;Will the United Nations General Assembly recognize a Palestinian state by 30 September 2011?&quot;</span>
<span class="o">&gt;</span> <span class="nx">chosennames</span><span class="cp">[</span><span class="mi">4</span><span class="cp">]</span>
<span class="nx">$</span><span class="err">`</span><span class="mi">4</span><span class="err">`</span>
<span class="nx">character</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>


<p>Question 4 for example, was unlabeled, though a topic like "Israel" might be appropriate. That's because the word "Palestine" did not appear in any of the labeled questions. Without that word, it's hard to tell what the question is about.</p>
<h1>Conclusion</h1>
<p>The random forests did a good job learning what they could from the data. Moreover, the models could be fit with only a few lines of code and were effective without modifying too many options. But it appears that there just weren't enough labeled data available here to label the questions appropriately. In Part 2 of this blog post, I consult an unsupervised machine learning approach to label these questions.</p>
                    </section>
                    <hr/>
                    <aside class="post-meta">
                        <p>Category: <a href="./category/r.html">R</a></p>
                        <p>Tags: <a href="./tag/machine-learning.html">machine learning</a>, </p>
                    </aside>
                    <hr/>
                </article>
            </li>
        </ol>
    </div>
        </div>

        <script src="./theme/js/main.js"></script>
    </body>
</html>